Here's a detailed Cursor instruction file for refactoring the existing application to use a Python-based backend while maintaining the same functionality and deployment:

```yaml
name: Refactor to Python Backend

steps:
  - name: Update Project Structure
    command: |
      mkdir -p packages/api_python/src/{functions,lib}
      touch packages/api_python/requirements.txt
      touch packages/api_python/host.json
      touch packages/api_python/local.settings.json

  - name: Install Python Dependencies
    command: |
      cd packages/api_python
      pip install azure-functions azure-cosmos langchain openai python-dotenv
      pip freeze > requirements.txt

  - name: Create Azure Function App
    language: python
    file: packages/api_python/host.json
    content: |
      {
        "version": "2.0",
        "extensionBundle": {
          "id": "Microsoft.Azure.Functions.ExtensionBundle",
          "version": "[3.*, 4.0.0)"
        }
      }

  - name: Implement Chat Function
    language: python
    file: packages/api_python/src/functions/chat_post/__init__.py
    content: |
      import azure.functions as func
      import json
      from ...lib.langchain_utils import generate_response

      def main(req: func.HttpRequest) -> func.HttpResponse:
          try:
              req_body = req.get_json()
              message = req_body.get('message')
              
              if not message:
                  return func.HttpResponse(
                      "Please pass a message in the request body",
                      status_code=400
                  )
              
              response = generate_response(message)
              
              return func.HttpResponse(
                  json.dumps({"response": response}),
                  mimetype="application/json",
                  status_code=200
              )
          except Exception as e:
              return func.HttpResponse(
                  f"An error occurred: {str(e)}",
                  status_code=500
              )

  - name: Implement Documents Post Function
    language: python
    file: packages/api_python/src/functions/documents_post/__init__.py
    content: |
      import azure.functions as func
      from ...lib.document_processor import process_document

      def main(req: func.HttpRequest) -> func.HttpResponse:
          try:
              file = req.files.get('file')
              if not file:
                  return func.HttpResponse(
                      "Please upload a file",
                      status_code=400
                  )
              
              result = process_document(file.read())
              
              return func.HttpResponse(
                  f"Document processed successfully: {result}",
                  status_code=200
              )
          except Exception as e:
              return func.HttpResponse(
                  f"An error occurred: {str(e)}",
                  status_code=500
              )

  - name: Implement Documents Get Function
    language: python
    file: packages/api_python/src/functions/documents_get/__init__.py
    content: |
      import azure.functions as func
      import json
      from ...lib.document_retriever import get_documents

      def main(req: func.HttpRequest) -> func.HttpResponse:
          try:
              documents = get_documents()
              
              return func.HttpResponse(
                  json.dumps({"documents": documents}),
                  mimetype="application/json",
                  status_code=200
              )
          except Exception as e:
              return func.HttpResponse(
                  f"An error occurred: {str(e)}",
                  status_code=500
              )

  - name: Implement LangChain Utilities
    language: python
    file: packages/api_python/src/lib/langchain_utils.py
    content: |
      from langchain.llms import AzureOpenAI
      from langchain.embeddings import OpenAIEmbeddings
      from langchain.vectorstores import Cosmos
      from langchain.chains import RetrievalQA
      import os
      from dotenv import load_dotenv

      load_dotenv()

      llm = AzureOpenAI(
          deployment_name=os.getenv("AZURE_OPENAI_DEPLOYMENT_NAME"),
          model_name=os.getenv("AZURE_OPENAI_MODEL_NAME"),
          api_key=os.getenv("AZURE_OPENAI_API_KEY"),
          api_version=os.getenv("AZURE_OPENAI_API_VERSION")
      )

      embeddings = OpenAIEmbeddings(
          deployment=os.getenv("AZURE_OPENAI_EMBEDDING_DEPLOYMENT_NAME"),
          model=os.getenv("AZURE_OPENAI_EMBEDDING_MODEL_NAME"),
          api_key=os.getenv("AZURE_OPENAI_API_KEY"),
          api_version=os.getenv("AZURE_OPENAI_API_VERSION")
      )

      vectorstore = Cosmos(
          collection_name=os.getenv("COSMOS_COLLECTION_NAME"),
          connection_string=os.getenv("COSMOS_CONNECTION_STRING"),
          embedding_function=embeddings
      )

      qa_chain = RetrievalQA.from_chain_type(
          llm=llm,
          chain_type="stuff",
          retriever=vectorstore.as_retriever()
      )

      def generate_response(query: str) -> str:
          response = qa_chain.run(query)
          return response

  - name: Implement Document Processor
    language: python
    file: packages/api_python/src/lib/document_processor.py
    content: |
      from langchain.document_loaders import PyPDFLoader
      from langchain.text_splitter import RecursiveCharacterTextSplitter
      from .langchain_utils import vectorstore
      import tempfile

      def process_document(file_content: bytes) -> str:
          with tempfile.NamedTemporaryFile(delete=False, suffix=".pdf") as temp_file:
              temp_file.write(file_content)
              temp_file_path = temp_file.name

          loader = PyPDFLoader(temp_file_path)
          documents = loader.load()

          text_splitter = RecursiveCharacterTextSplitter(chunk_size=1000, chunk_overlap=200)
          splits = text_splitter.split_documents(documents)

          vectorstore.add_documents(splits)

          return f"Processed {len(splits)} text chunks"

  - name: Implement Document Retriever
    language: python
    file: packages/api_python/src/lib/document_retriever.py
    content: |
      from .langchain_utils import vectorstore

      def get_documents():
          # This is a placeholder. You'll need to implement the actual retrieval logic
          # based on your specific requirements and how you've structured your data in Cosmos DB.
          return ["Document 1", "Document 2", "Document 3"]

  - name: Update azure.yaml
    language: yaml
    file: azure.yaml
    content: |
      name: serverless-chat-langchainjs
      services:
        webapp:
          project: ./packages/webapp
          host: staticwebapp
        api:
          project: ./packages/api_python
          host: function
          language: python

  - name: Update GitHub Actions Workflow
    language: yaml
    file: .github/workflows/azure-dev.yml
    content: |
      name: Azure Developer CLI
      
      on:
        push:
          branches: [ main ]
        pull_request:
          branches: [ main ]
      
      jobs:
        build:
          runs-on: ubuntu-latest
          
          steps:
          - uses: actions/checkout@v2
          
          - name: Set up Python
            uses: actions/setup-python@v2
            with:
              python-version: '3.9'
          
          - name: Install Azure Functions Core Tools
            run: npm install -g azure-functions-core-tools@4
          
          - name: Install dependencies
            run: |
              cd packages/api_python
              pip install -r requirements.txt
          
          - name: Set up Azure Developer CLI
            uses: Azure/setup-azd@v1
          
          - name: Login to Azure
            run: azd auth login --use-device-code
          
          - name: Provision and deploy infrastructure
            run: azd up --debug
```

This Cursor instruction file provides a detailed guide for refactoring the existing application to use a Python-based backend while maintaining the same functionality and deployment structure. Here's a summary of the changes:

1. Updated the project structure to include a new `api_python` directory.
2. Installed necessary Python dependencies.
3. Created Azure Function App configuration.
4. Implemented Python versions of the chat, documents_post, and documents_get functions.
5. Created utility files for LangChain, document processing, and document retrieval.
6. Updated the `azure.yaml` file to reflect the new Python-based API.
7. Modified the GitHub Actions workflow to support Python deployment.

These instructions will help you refactor the application to use a Python backend while maintaining the existing functionality and deployment process[1].

Citations:
[1] https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/10476480/408d35ff-a194-40a2-a3c8-6d722e0d3a2d/paste.txt